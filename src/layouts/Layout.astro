---
import "../styles/reset.css";
import "../styles/global.css";

import { name, themeColor, twitterHandle } from "spectre:globals";
import Background from "../components/Background.astro";
import LayoutGrid from "../components/LayoutGrid.astro";
import Navbar from "../components/Navbar.astro";
import ScrollToTop from "../components/ScrollToTop.astro";

interface Props {
  title: string;
  description?: string;
  image?: ImageMetadata;
  pagefindIgnore?: boolean;
  article?: {
    createdAt: Date;
    updatedAt?: Date;
  };
}

const { title, description, image, pagefindIgnore, article } = Astro.props;
---

<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />

		<script is:inline>
			(function () {
				try {
					const TTL_MS = 1000 * 60 * 60 * 24; // 24h
					const stored = localStorage.getItem('theme');
					const expRaw = localStorage.getItem('theme_expires');
					const exp = expRaw ? parseInt(expRaw, 10) : 0;
					const now = Date.now();
					const storedValid = !!stored && !!exp && exp > now;
					const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
					const isDark = storedValid ? stored === 'dark' : prefersDark;
					const root = document.documentElement;
					if (!storedValid) {
						// Clear expired preference so OS setting can take effect next time too
						try { localStorage.removeItem('theme'); localStorage.removeItem('theme_expires'); } catch {}
					}
					if (isDark) {
						root.classList.add('dark');
						root.style.colorScheme = 'dark';
					} else {
						root.classList.remove('dark');
						root.style.colorScheme = 'light';
					}
				} catch {}

				// React to OS theme changes only when there is no explicit user preference stored
				try {
					const mql = window.matchMedia('(prefers-color-scheme: dark)');
					mql.addEventListener('change', (e) => {
						try {
							const expRaw = localStorage.getItem('theme_expires');
							const exp = expRaw ? parseInt(expRaw, 10) : 0;
							if (localStorage.getItem('theme') && exp && exp > Date.now()) return; // Respect unexpired choice
						} catch {}
						const root = document.documentElement;
						if (e.matches) {
							root.classList.add('dark');
							root.style.colorScheme = 'dark';
						} else {
							root.classList.remove('dark');
							root.style.colorScheme = 'light';
						}
						window.dispatchEvent(new CustomEvent('theme-changed', { detail: { isDark: e.matches } }));
					});
				} catch {}
			})();
		</script>

		<title>{title}</title>
		{description && <meta name="description" content={description} />}
		<meta name="theme-color" content={themeColor}>

		<link rel="canonical" href={Astro.site} />

		<meta name="og:title" content={title} />
		{description && <meta name="og:description" content={description} />}
		<meta name="og:image" content={image?.src || '/img/og.png'} />
		<meta name="og:url" content={Astro.site} />
		{!article && <meta name="og:type" content="website" />}
		<meta name="og:locale" content="en" />

		{article && (
			<meta name="og:type" content="article" />
			<meta property="article:published_time" content={article.createdAt.toISOString()} />
			<meta name="author" content={name} />
		)}

		{article && article.updatedAt && (
			<meta property="article:modified_time" content={article.updatedAt.toISOString()} />
		)}

		<meta name="twitter:card" content="summary_large_image" />
		{twitterHandle && (
			<meta name="twitter:site" content={twitterHandle} />
			<meta name="twitter:creator" content={twitterHandle} />
		)}
		<meta name="twitter:title" content={title} />
		{description && <meta name="twitter:description" content={description} />}
		<meta name="twitter:image" content={image?.src || '/img/og.png'} />
	</head>
	<body>
		<main class="w-full max-w-screen-xl mx-auto flex flex-col gap-4 pt-0 pb-8 sm:gap-8 sm:py-8" data-pagefind-ignore={pagefindIgnore}>
			<Navbar />
			<LayoutGrid>
				<slot name="left" slot="left" />
				<slot name="right" slot="right" />
			</LayoutGrid>
			<slot name="404" />
		</main>
		<ScrollToTop />
		<Background />
		<script is:inline>
			// Highlight and scroll to search terms from URL parameter
			(function() {
				const params = new URLSearchParams(window.location.search);
				const highlightTerm = params.get('highlight');

				if (!highlightTerm) return;

				// Global state for navigation
				let searchHighlights = [];
				let currentHighlightIndex = 0;

				// Function to highlight text and scroll to first match
				function highlightAndScroll() {
					// Get the main content area (avoiding navbar and other UI elements)
					const contentArea = document.querySelector('[data-pagefind-body]') ||
					                   document.querySelector('article') ||
					                   document.querySelector('main');

					if (!contentArea) return;

					// Create a tree walker to find text nodes
					const walker = document.createTreeWalker(
						contentArea,
						NodeFilter.SHOW_TEXT,
						{
							acceptNode: function(node) {
								// Skip script and style tags
								const parent = node.parentElement;
								if (parent && (parent.tagName === 'SCRIPT' ||
								              parent.tagName === 'STYLE' ||
								              parent.tagName === 'CODE' ||
								              parent.tagName === 'PRE')) {
									return NodeFilter.FILTER_REJECT;
								}
								return NodeFilter.FILTER_ACCEPT;
							}
						}
					);

					const textNodes = [];
					let node;
					while (node = walker.nextNode()) {
						textNodes.push(node);
					}

					// Create regex for case-insensitive search that matches whole words
					// but expands to include the full word even if search term is partial
					const escapedTerm = highlightTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
					const searchRegex = new RegExp(`\\b\\w*${escapedTerm}\\w*\\b`, 'gi');
					searchHighlights = [];

					// Process text nodes and wrap matches
					textNodes.forEach(textNode => {
						const text = textNode.textContent;
						if (searchRegex.test(text)) {
							const parent = textNode.parentNode;
							const fragment = document.createDocumentFragment();
							let lastIndex = 0;

							// Reset regex for exec
							searchRegex.lastIndex = 0;

							let match;
							while ((match = searchRegex.exec(text)) !== null) {
								// Add text before match
								if (match.index > lastIndex) {
									fragment.appendChild(
										document.createTextNode(text.slice(lastIndex, match.index))
									);
								}

								// Create highlighted span
								const mark = document.createElement('mark');
								mark.className = 'search-highlight';
								mark.textContent = match[0];
								fragment.appendChild(mark);

								// Store in highlights array
								searchHighlights.push(mark);

								lastIndex = match.index + match[0].length;
							}

							// Add remaining text
							if (lastIndex < text.length) {
								fragment.appendChild(
									document.createTextNode(text.slice(lastIndex))
								);
							}

							// Replace text node with fragment
							parent.replaceChild(fragment, textNode);
						}
					});

					// Set first highlight as current and scroll to it
					if (searchHighlights.length > 0) {
						currentHighlightIndex = 0;
						updateCurrentHighlight();

						setTimeout(() => {
							searchHighlights[0].scrollIntoView({
								behavior: 'smooth',
								block: 'center'
							});

							// Add a temporary pulse animation to draw attention
							searchHighlights[0].style.animation = 'pulse 2s ease-in-out';
						}, 100);
					}

					// Show indicator with navigation controls
					if (searchHighlights.length > 0) {
						createSearchIndicator();
						// Add escape key listener
						document.addEventListener('keydown', handleEscapeKey);
					}
				}

				// Update current highlight styling
				function updateCurrentHighlight() {
					// Remove current class from all highlights
					searchHighlights.forEach(mark => mark.classList.remove('current'));
					// Add current class to active highlight
					if (searchHighlights[currentHighlightIndex]) {
						searchHighlights[currentHighlightIndex].classList.add('current');
					}
					// Update indicator counter
					updateIndicatorCounter();
				}

				// Navigation functions
				window.nextHighlight = function() {
					if (searchHighlights.length === 0) return;
					currentHighlightIndex = (currentHighlightIndex + 1) % searchHighlights.length;
					updateCurrentHighlight();
					searchHighlights[currentHighlightIndex].scrollIntoView({
						behavior: 'smooth',
						block: 'center'
					});
				}

				window.prevHighlight = function() {
					if (searchHighlights.length === 0) return;
					currentHighlightIndex = (currentHighlightIndex - 1 + searchHighlights.length) % searchHighlights.length;
					updateCurrentHighlight();
					searchHighlights[currentHighlightIndex].scrollIntoView({
						behavior: 'smooth',
						block: 'center'
					});
				}

				// Create search indicator with navigation
				function createSearchIndicator() {
					const indicator = document.createElement('div');
					indicator.className = 'search-indicator';
					indicator.id = 'search-indicator';

					const showNavigation = searchHighlights.length > 1;

					indicator.innerHTML = `
						<div class="flex items-center gap-2">
							<span class="search-term" title="Search term">"${highlightTerm}"</span>
							
							${showNavigation ? `
								<button onclick="prevHighlight()" class="nav-btn" title="Previous match">
									<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
										<polyline points="15,18 9,12 15,6"></polyline>
									</svg>
								</button>
							` : ''}

							<span id="search-counter">${searchHighlights.length === 1 ? '1 match found' : `1 / ${searchHighlights.length}`}</span>

							${showNavigation ? `
								<button onclick="nextHighlight()" class="nav-btn" title="Next match">
									<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
										<polyline points="9,18 15,12 9,6"></polyline>
									</svg>
								</button>
							` : ''}

							<button onclick="clearSearchHighlights()" title="Clear highlights (ESC)">Clear</button>
						</div>
					`;

					document.body.appendChild(indicator);
				}

				// Update counter in indicator
				function updateIndicatorCounter() {
					const counter = document.getElementById('search-counter');
					if (counter && searchHighlights.length > 1) {
						counter.textContent = `${currentHighlightIndex + 1} / ${searchHighlights.length}`;
					}
				}

				// Clear highlights function
				window.clearSearchHighlights = function() {
					// Remove all highlight marks
					document.querySelectorAll('.search-highlight').forEach(mark => {
						const parent = mark.parentNode;
						while (mark.firstChild) {
							parent.insertBefore(mark.firstChild, mark);
						}
						parent.removeChild(mark);
					});

					// Remove indicator
					const indicator = document.querySelector('.search-indicator');
					if (indicator) {
						indicator.remove();
					}

					// Remove highlight parameter from URL
					const url = new URL(window.location);
					url.searchParams.delete('highlight');
					window.history.replaceState({}, '', url);

					// Remove escape key listener
					document.removeEventListener('keydown', handleEscapeKey);
				}

				// Handle escape key to close search results
				function handleEscapeKey(event) {
					if (event.key === 'Escape' && document.querySelector('.search-indicator')) {
						clearSearchHighlights();
					}
				}

				// Run highlighting after page loads
				if (document.readyState === 'loading') {
					document.addEventListener('DOMContentLoaded', highlightAndScroll);
				} else {
					highlightAndScroll();
				}
			})();
		</script>
	</body>
</html>
